\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{enumerate}
\usepackage{algorithmic}

\title{CS 344 Assignment 3}
\author{Craig Perkins, Alex Tang, Steve Grzenda}
\date{Due April 4, 2014}

\begin{document}
\maketitle

\section*{Problem 1}
Assume we have a function \verb|dist(a,b)| which returns the distance between
two pairs of coordinates in constant time and a function \verb|min(a,b)| which
returns the minimum of \verb|a| and \verb|b| in constant time.

\begin{verbatim}
// red[], blue[] are arrays of coordinates
function Takeshi(red[], blue[]):
  redIndex = 0
  blueIndex = 0
  minRope = dist(red[0], blue[0])
  while (redIndex != length(red) and blueIndex != length(blue)):
    bothMove  = dist(red[redIndex + 1], blue[blueIndex + 1])
    redMoves  = dist(red[redIndex + 1], blue[blueIndex])
    blueMoves = dist(red[redIndex], blue[blueIndex + 1])
    if (bothMove <= minRope):
      redIndex++
      blueIndex++
    else if (redMoves <= minRope):
      redIndex++
    else if (blueMoves <= minRope):
      blueIndex++
    else:
      minRope = min(redMoves, blueMoves)
  return minRope
\end{verbatim}

This algorithm will return minimum length of rope needed. It will run in worst
case $O(n + m) * O(1)$ where $n$ is the length of the red path and $m$ is the length
of the blue path and the $O(1)$ is the cost of calling \verb|dist| on two
points.

\section*{Problem 2}
\begin{enumerate}[A.]
    \item 
    \item 
\end{enumerate}

\section*{Problem 3}
\begin{enumerate}[A.]
    \item In the worse case, if there is an exponential number of paths,
      then in order to output all of them, you will need an exponential amount
      of time. If you were to save these paths, it would take exponential
      memory space. The following algorithm returns a set of all the paths
      from \verb|s| to \verb|t|:
\begin{verbatim}
// path is defined as a list from source s to destination t, i.e.:
//   path = (s, ... , t)
// path.last() returns the last vertex in the path list, i.e.:
//   (s, ..., t).last() returns t
// path.extend(v) means add v to the end of the path, i.e.:
//   (s1, s2).extend(v) returns (s1, s2, v)

function find_all_paths(G, s, t):
  all_paths = {}
  queue = { (s) }

  while (queue is not empty):
    path = queue.remove()
    u = path.last()
    for every edge(u, v) in G:
      if (v == t):
        all_paths.add(path)  // reached destination t
      else:
        queue.add(path.extend(v))
  return all_paths
\end{verbatim}
    \item Topologically sort the graph and check if there is an edge between
      each consecutive vertex. This algorithm will run in $O(|V| + |E|)$.
\begin{verbatim}
function path_exists(G):
  H = topological_sort(G)
  // vertexes are now labeled 1, 2, ..., n in topological order
  for i in [1, n - 1]:
    if (edge(i, i+1) does not exist in G):
      return false
  return true
\end{verbatim}

\end{enumerate}

\section*{Problem 4}
Given the list of international conflicts in the last ten years, create a graph
where each vertex represents a country. Create an edge between two vertices
if there is a conflict between those two countries. Next, check if
the graph is bipartite using the following algorithm: 

ALEX WILL FILL THIS IN

If this graph is bipartite, then it is possible to make the assignment. Each of
the two tables will consist of all the vertices of each disjoint set of the
bipartite graph.

DO RUNNING TIME
\end{document}
